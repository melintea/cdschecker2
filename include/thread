/*
 *  $Id: $
 *
 *  Copyright 2024 Aurelian Melinte.
 *  Released under GPL 3.0 or later.
 *
 *  You need a C++0x compiler.
 *
 */

#ifndef INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94
#define INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94

#pragma once

#include "model-assert.h"
#include "threads.h"
#include "utils.h"

#include <cstddef>
#include <functional>
#include <utility>

namespace impl {

struct thread_data
{
    thrd_t _tid{.priv=nullptr};

    using func_t = std::function<void(void)>;
    func_t _func;

    using guard_t = utils::ptr_guard<thread_data>;

    thread_data()  = default;
    ~thread_data() = default;

    thread_data( const thread_data& other )            = delete;
    thread_data& operator=( const thread_data& other ) = delete;

    thread_data( thread_data&& other )                 = delete; 
    thread_data& operator=( thread_data&& other )      = delete;
}; // thread_data

} // impl
namespace std {

/*
 * Minimal implementation. Not fully standard compliant.
 */
class thread
{
protected:

    impl::thread_data* _ptdata{nullptr};

    void release()
    {
        delete _ptdata; _ptdata = nullptr;
    }

    static void run(void* pv)
    {
        model_print("thread::run\n");
        impl::thread_data* p(reinterpret_cast<impl::thread_data*>(pv));
        MODEL_ASSERT(p);
        MODEL_ASSERT(p->_func != nullptr);
        p->_func();
    }

public:

    using id = thrd_t;

    template<typename F, typename... ARGS>
    thread(F&& f, ARGS&&... args)
        : _ptdata(new impl::thread_data())
    {
        model_print("thread::thread<>\n");
        MODEL_ASSERT(_ptdata);
        _ptdata->_func = [&]() { std::forward<F>(f)(std::forward<ARGS>(args)...); };
        thrd_create(&_ptdata->_tid, &thread::run, _ptdata);
    }

    thread() {
        model_print("thread::thread()\n");
    }
    ~thread()
    {
        model_print("thread::~thread\n");
        // The model checker will barf if the thread was not joined
        MODEL_ASSERT( ! joinable());
        release();
    }

    thread( const thread& other )            = delete;
    thread& operator=( const thread& other ) = delete;

    //thread( thread&& other )                 = delete;
    thread( thread&& other ) noexcept {
        model_print("thread::thread&&\n");
        swap(other);
    }

    //thread& operator=( thread&& other )      = delete;
    thread& operator=( thread&& other ) noexcept {
        model_print("thread::=&&\n");
        if (this != &other) {
            // should std::terminate() current thread but API not supported
            swap(other);
        }
        return *this;
    }

    void swap(thread& other) noexcept {
        MODEL_ASSERT(_ptdata == nullptr);
        MODEL_ASSERT(other._ptdata->_tid.priv != nullptr);
        std::swap(_ptdata,  other._ptdata);
    }

    id   get_id() const noexcept 
    { 
        return _ptdata->_tid; 
    }

    void join() 
    { 
        if  (joinable()) {
            (void)thrd_join(_ptdata->_tid); 
            release();
        }
    } 
    bool joinable() const noexcept { return _ptdata && _ptdata->_tid.priv != nullptr; }

}; // thread

/*
 * Minimal implementation. Not fully standard compliant.
 */
class jthread : public thread
{
public:

    using std::thread::thread;

    jthread( jthread&& other ) noexcept {
        thread::swap(other);
    }
    jthread& operator=( jthread&& other ) noexcept {
        if (this != &other) {
            thread::swap(other);
        }
        return *this;
    }

    ~jthread()
    {
        if (joinable()) {
            thrd_join(_ptdata->_tid);
        }
    }
}; //jthread

} //namespace std


#endif //#define INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94
