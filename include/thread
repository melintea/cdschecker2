/*
 *  $Id: $
 *
 *  Copyright 2024 Aurelian Melinte.
 *  Released under GPL 3.0 or later.
 *
 *  You need a C++0x compiler.
 *
 */

#ifndef INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94
#define INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94

#pragma once

#include "model-assert.h"
#include "threads.h"
#include "utils.h"

#include <cstddef>
#include <functional>
#include <utility>

namespace impl {

struct thread_data
{
    thrd_t _tid{.priv=nullptr};

    using func_t = std::function<void(void)>;
    func_t _func;

    using guard_t = utils::ptr_guard<thread_data>;

    thread_data()  = default;
    ~thread_data() = default;

    thread_data( const thread_data& other )            = delete;
    thread_data& operator=( const thread_data& other ) = delete;

    thread_data( thread_data&& other )                 = delete; 
    thread_data& operator=( thread_data&& other )      = delete;
}; // thread_data

} // impl
namespace std {

/*
 * Minimal implementation. Not fully standard compliant.
 */
class thread
{
protected:

    impl::thread_data* _ptdata{nullptr};

    static void run(void* pv)
    {
        impl::thread_data* p(reinterpret_cast<impl::thread_data*>(pv));
        MODEL_ASSERT(p);
        MODEL_ASSERT(p->_func != nullptr);
        p->_func();
    }

public:

    using id = thrd_t;

    template<typename F, typename... ARGS>
    explicit thread(F&& f, ARGS&&... args)
        : _ptdata(new impl::thread_data())
    {
        MODEL_ASSERT(_ptdata);
        _ptdata->_func = [&]() { std::forward<F>(f)(std::forward<ARGS>(args)...); };
        thrd_create(&_ptdata->_tid, &thread::run, _ptdata);
    }

    thread()  = default;
    ~thread()
    {
        // The leak is intentional - the model checked will barf otherwise
        //delete _ptdata;
    }

    thread( const thread& other )            = delete;
    thread& operator=( const thread& other ) = delete;

    //thread( thread&& other )                 = delete;
    thread( thread&& other ) {
        MODEL_ASSERT(other._ptdata->_tid.priv != nullptr);
        std::swap(_ptdata,  other._ptdata);
    }

    //thread& operator=( thread&& other )      = delete;
    thread& operator=( thread&& other ) {
        if (this != &other) {
            // should std::terminate() current thread but API not supported
            MODEL_ASSERT(_ptdata->_tid.priv == nullptr);
            MODEL_ASSERT(other._ptdata->_tid.priv != nullptr);
            std::swap(_ptdata,  other._ptdata);
        }
        return *this;
    }

    id   get_id() const noexcept 
    { 
        return _ptdata->_tid; 
    }

    void join() 
    { 
        if  (_ptdata->_tid.priv) {
            (void)thrd_join(_ptdata->_tid); 
        }
    } 
    bool joinable() const noexcept { return _ptdata->_tid.priv != nullptr; }

}; // thread

/*
 * Minimal implementation. Not fully standard compliant.
 */
class jthread : public thread
{
public:

    using std::thread::thread;

    ~jthread()
    {
        if (joinable()) {
            thrd_join(_ptdata->_tid);
        }
    }
}; //jthread

} //namespace std


#endif //#define INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94
