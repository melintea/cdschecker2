/*
 *  $Id: $
 *
 *  Copyright 2024 Aurelian Melinte.
 *  Released under GPL 3.0 or later.
 *
 *  You need a C++0x compiler.
 *
 */

#ifndef INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94
#define INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94

#pragma once

#include "model-assert.h"
#include "threads.h"
#include "utils.h"

#include <cstddef>
#include <functional>
#include <type_traits>
#include <utility>

namespace impl {

template <typename T> struct deduct_type;

template <typename RET, typename CLASS, typename... ARGS> 
struct deduct_type< RET(CLASS::*)(ARGS...) const>
{
    using type = std::function<RET(ARGS...)>;
};

template <typename CLOSURE> auto wrap(const CLOSURE& fn)
{
    return typename impl::deduct_type< decltype(&CLOSURE::operator()) >::type(fn);
}

struct thread_data
{
    thrd_t _tid{.priv=nullptr};

    using func_t = std::function<void(void)>;
    func_t _func;

    using guard_t = utils::ptr_guard<thread_data>;

    thread_data()  = default;
    ~thread_data() = default;

    thread_data( const thread_data& other )            = delete;
    thread_data& operator=( const thread_data& other ) = delete;

    thread_data( thread_data&& other )                 = delete; 
    thread_data& operator=( thread_data&& other )      = delete;
}; // thread_data

} // impl

namespace std {

/*
 * Minimal implementation. Not fully standard compliant.
 */
class thread
{
protected:

    impl::thread_data* _ptdata{nullptr};

    void release()
    {
        model_print("thread::release %p %p\n", this, _ptdata);
        delete _ptdata; _ptdata = nullptr;
    }

    static void run(void* pv)
    {
        utils::scope_print s("thread::run %p\n", pv);
        impl::thread_data* p(reinterpret_cast<impl::thread_data*>(pv));
        MODEL_ASSERT(p);
        MODEL_ASSERT(p->_func != nullptr);
        //std::invoke(p->_func);
        p->_func();
    }

public:

    using id = thrd_t;

    template<typename F, typename... ARGS>
    thread(F&& f, ARGS&&... args)
        : _ptdata(new impl::thread_data())
    {
        utils::scope_print s("thread::thread<> %p %p\n", this, _ptdata);
        MODEL_ASSERT(_ptdata);
	
        auto ftemp = impl::wrap(std::forward<F>(f));
        _ptdata->_func = ftemp; //[&]() { std::forward<F>(f)(std::forward<ARGS>(args)...); };
        thrd_create(&_ptdata->_tid, &thread::run, _ptdata);
        MODEL_ASSERT(_ptdata->_tid.priv);
    }

    thread() {
        utils::scope_print s("thread::thread() %p\n", this);
    }
    ~thread()
    {
        utils::scope_print s("thread::~thread  %p %p\n", this, _ptdata);
        // The model checker will barf if the thread was not joined
        MODEL_ASSERT( ! joinable());
        release();
    }

    thread( const thread& other )            = delete;
    thread& operator=( const thread& other ) = delete;

    //thread( thread&& other )                 = delete;
    thread( thread&& other ) noexcept {
        utils::scope_print s("thread::thread&& %p %p\n", this, _ptdata);
        swap(other);
    }

    //thread& operator=( thread&& other )      = delete;
    thread& operator=( thread&& other ) noexcept {
        utils::scope_print s("thread::=&&\n");
        if (this != &other) {
            // should std::terminate() current thread but API not supported
            swap(other);
        }
        return *this;
    }

    void swap(thread& other) noexcept {
        MODEL_ASSERT(_ptdata == nullptr);
        MODEL_ASSERT(other._ptdata != nullptr);
        std::swap(_ptdata,  other._ptdata);
    }

    id   get_id() const noexcept 
    { 
        return _ptdata->_tid; 
    }

    void join() 
    { 
        utils::scope_print s("thread::join %p %p\n", this, _ptdata);
        if  (joinable()) {
            model_print("thread::join %p %p\n", this, _ptdata);
            (void)thrd_join(_ptdata->_tid); 
            release();
        }
    } 
    //bool joinable() const noexcept { return (_ptdata && _ptdata->_tid.priv); }
    bool joinable() const noexcept { return _ptdata; }

}; // thread

/*
 * Minimal implementation. Not fully standard compliant.
 */
class jthread : public thread
{
public:

    using std::thread::thread;

    jthread( jthread&& other ) noexcept {
        thread::swap(other);
    }
    jthread& operator=( jthread&& other ) noexcept {
        if (this != &other) {
            thread::swap(other);
        }
        return *this;
    }

    ~jthread()
    {
        join();
    }
}; //jthread

} //namespace std


#endif //#define INCLUDED_thread_hpp_ce4b651b_3924_4036_bc03_e9127fe99f94
